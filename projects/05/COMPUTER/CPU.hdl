// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/5/CPU.hdl
/**
 * The Hack Central Processing unit (CPU).
 * Parses the binary code in the instruction input and executes it according to the
 * Hack machine language specification. In the case of a C-instruction, computes the
 * function specified by the instruction. If the instruction specifies to read a memory
 * value, the inM input is expected to contain this value. If the instruction specifies
 * to write a value to the memory, sets the outM output to this value, sets the addressM
 * output to the target address, and asserts the writeM output (when writeM = 0, any
 * value may appear in outM).
 * If the reset input is 0, computes the address of the next instruction and sets the
 * pc output to that value. If the reset input is 1, sets pc to 0.
 * Note: The outM and writeM outputs are combinational: they are affected by the
 * instruction's execution during the current cycle. The addressM and pc outputs are
 * clocked: although they are affected by the instruction's execution, they commit to
 * their new values only in the next cycle.
 */
CHIP CPU {

    IN  inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current
                         // program (reset==1) or continue executing
                         // the current program (reset==0).

    OUT outM[16],        // M value output
        writeM,          // Write to M? 
        addressM[15],    // Address in data memory (of M)
        pc[15];          // address of next instruction

    PARTS:
    // Replace this comment with your code.

    // instruction이 어떤 명령어인지 해석해야한다.
    // instruction의 마지막 비트가 0인 경우 주소 명령어, 1인 경우 계산 명령어로 해석한다.
    DMux(in=true, sel=instruction[15], a=isAddrInst, b=isCmpInst);

    // 주소 명령어: @value
    // 0vvv vvvv vvvv vvvv
    
    // 계산 명령어: dest=comp;jump
    // 111a c1c2c3c4 c5c6d1d2 d3j1j2j3

    // 계산 명령어의 dest 필드
    // | d1 | d2 | d3 | destination(where to store calculated value) |
    // |----|----|----|----------------------------------------------|
    // | 0  | 0  | 0  | null                                         |
    // | 0  | 0  | 1  | Memory[A]                                    |
    // | 0  | 1  | 0  | D-Regsiter                                   |
    // | 0  | 1  | 1  | Memory[A], D-Regsiter                        |
    // | 1  | 0  | 0  | A-Regsiter                                   |
    // | 1  | 0  | 1  | A-Regsiter, Memory[A]                        |
    // | 1  | 1  | 0  | A-Regsiter, D-Register                       |
    // | 1  | 1  | 1  | A-Regsiter, Memory[A], D-Register            |

    // 주소 레지스터의 입력 데이터는 주소 명령어 그 자체이거나 또는 계산 명령어 목적지가 주소 레지스터인 경우의 ALU의 출력이다.
    // 따라서, 주소 레지스터의 입력을 instruction과 outM 중 선택해야하므로 Mux16을 사용한다.
    Mux16(a=outALU, b=instruction, sel=isAddrInst, out=addrRegIn);

    // 주소 레지스터에 데이터를 저장하는 경우는 주소 명령어를 사용했거나, 계산 명령어의 목적지가 주소 레지스터로 설정된 경우이다.
    // 즉, 어셈블리 명령에 @value 또는 A[MD]=comp[;jump]를 사용한 경우이다.
    // 그리고 계산 명령어의 목적지가 주소 레지스터로 설정된 경우는 계산 명령어의 dest 필드 중 d1 비트가 1인 모든 dest 필드 조합으로 생각할 수 있다.
    Or(a=isAddrInst, b=instruction[5], out=doLoadAddrReg);

    // 데이터 메모리에서의 M의 주소를 ARegister의 0~14까지의 비트 값으로 출력한다.
    ARegister(in=addrRegIn, load=doLoadAddrReg, out=outAddrReg, out[0..14]=addressM);

    // 데이터 레지스터에 데이터를 저장하는 경우는 명령어가 계산 명령어이면서, 계산 명령어의 목적지가 데이터 레지스터로 설정된 경우이다.
    // 즉, 어셈블리 명령에 [AM]D=comp[;jump]를 사용한 경우이다.
    // 그리고 계산 명령어의 목적지가 데이터 레지스터로 설정된 경우는 계산 명령어의 dest 필드 중 d2 비트가 1인 모든 dest 필드 조합으로 생각할 수 있다.
    And(a=isCmpInst, b=instruction[4], out=doLoadDataReg);
    DRegister(in=outALU, load=doLoadDataReg, out=outDataReg);

    // ALU에서 처리할 연산의 두 피연산자 입력은 데이터 레지스터의 출력과 주소 레지스터의 출력 또는 (데이터) 메모리의 입력으로 구성된다.
    // ALU에서 처리할 연산의 한 피연산를 주소 레지스터의 출력 또는 (데이터) 메모리의 입력 중 선택하기 위해 계산 명령어의 comp 필드 중 a 비트를 사용한다.
    // comp 필드 중 a 비트의 목적에 대해서는 108 페이지 명령어 실행에 대한 설명 내용을 확인 할 것.
    // 참고로 주소 명령어가 아닌 명령어 중, 명령어에 M에 접근하는 어셈블리 코드가 없을 경우 해당 코드는 1110로 시작하는 기계어로 번역된다.
    And(a=isCmpInst, b=instruction[12], out=isMemData);
    Mux16(a=outAddrReg, b=inM, sel=isMemData, out=outAddrRegDataOrMemData);

    // 계산 명령어의 comp 필드
    // | when a=0 | c1 | c2 | c3 | c4 | c5 | c6 | when a=1 |
    // |----------|----|----|----|----|----|----|----------|
    // | 0        | 1  | 0  | 1  | 0  | 1  | 0  |          |
    // | !D       | 0  | 0  | 1  | 1  | 0  | 1  |          |
    // | !A       | 1  | 1  | 0  | 0  | 0  | 1  | !M       |
    // | -D       | 0  | 0  | 1  | 1  | 1  | 1  |          |
    // | -A       | 1  | 1  | 0  | 0  | 1  | 1  | -M       |
    // | D+A      | 0  | 0  | 0  | 0  | 1  | 0  | D+M      |
    // | D&A      | 0  | 0  | 0  | 0  | 0  | 0  | D&M      |

    // ALU 진리표
    // | out= | zx | nx | zy | ny | f | no |
    // |------|----|----|----|----|---|----|
    // | 0    | 1  | 0  | 1  | 0  | 1 | 0  |
    // | !x   | 0  | 0  | 1  | 1  | 0 | 1  |
    // | !y   | 1  | 1  | 0  | 0  | 0 | 1  |
    // | -x   | 0  | 0  | 1  | 1  | 1 | 1  |
    // | -y   | 1  | 1  | 0  | 0  | 1 | 1  |
    // | x+y  | 0  | 0  | 0  | 0  | 1 | 0  |
    // | x&y  | 0  | 0  | 0  | 0  | 0 | 0  |


    // ALU의 입력 x는 데이터 레지스터의 출력을, 입력 y는 주소 레지스터 출력 또는 (데이터) 메모리의 입력이다.
    // ALU의 zx, nx, zy, ny, f, no 입력은 명령어가 계산 명령어일 때 가능하다.
    // ALU 진리표의 입력 비트 조합이 계산 명령어의 comp 필드 비트 조합과 같으므로 명령어가 계산 명령어일 때,
    // comp 필드의 c1~c6 비트를 zx~no 입력에 맞춰 설정한다.
    And(a=isCmpInst, b=instruction[11], out=doZx);
    And(a=isCmpInst, b=instruction[10], out=doNx);
    And(a=isCmpInst, b=instruction[9], out=doZy);
    And(a=isCmpInst, b=instruction[8], out=doNy);
    And(a=isCmpInst, b=instruction[7], out=doAddOrAdd);
    And(a=isCmpInst, b=instruction[6], out=doNo);
    ALU(x=outDataReg, y=outAddrRegDataOrMemData, zx=doZx,  nx=doNx, zy=doZy, ny=doNy, f=doAddOrAdd, no=doNo, out=outM, zr=isZrOut, ng=isNgOut, out=outALU);

    // 계산 명령어의 dest 필드 중 d3 비트는 ALU의 출력의 목적지를 주소 레지스터의 값을 주소로하는 (데이터) 메모리의 위치(= M[A])가 되도록 한다.
    And(a=isCmpInst, b=instruction[3], out=writeM);

    // 계산 명령어의 jump 필드
    // | j1        | j2        | j3        | symbol | effect             |
    // | (out < 0) | (out = 0) | (out > 0) |        |                    |
    // |-----------|-----------|-----------|--------|--------------------|
    // | 0         | 0         | 0         | null   | not jump           |
    // | 0         | 0         | 1         | JGT    | jump when out > 0  |
    // | 0         | 1         | 0         | JEQ    | jump when out = 0  |
    // | 0         | 1         | 1         | JGE    | jump when out >= 0 |
    // | 1         | 0         | 0         | JLT    | jump when out < 0  |
    // | 1         | 0         | 1         | JNE    | jump when out != 0 |
    // | 1         | 1         | 0         | JLE    | jump when out <= 0 |
    // | 1         | 1         | 1         | JMP    | do jump            |

    // ALU 연산 결과가 0과 같거나 0보다 작은지 또는 0보다 큰지 구분한다.
    Or(a=isZrOut, b=isNgOut, out=isZrOrNgOut);
    Not(in=isZrOrNgOut, out=isPosOut);

    // out이 0보다 커서 jump를 해야하지는지 결정한다.
    And(a=isCmpInst, b=instruction[0], out=hitJ3Fld);
    And(a=hitJ3Fld, b=isPosOut, out=doJGT);

    // out이 0과 같아 jump를 해야하지는지 결정한다.
    And(a=isCmpInst, b=instruction[1], out=hitJ2Fld);
    And(a=hitJ2Fld, b=isZrOut, out=doJEQ);

    // out이 0보다 작아서 jump를 해야하지는지 결정한다.
    And(a=isCmpInst, b=instruction[2], out=hitJ1Fld);
    And(a=hitJ1Fld, b=isNgOut, out=doJLT);

    // 위 3가지 jump 결과를 조합하여 나머지 out 조건에 대한 jump를 결정한다.
    Or(a=doJGT, b=doJEQ, out=doJGE);

    And(a=hitJ3Fld, b=hitJ1Fld, out=notHitJ2Fld);
    Not(in=isZrOut, out=isNotZrOut);
    And(a=notHitJ2Fld, b=isNotZrOut, out=doJNE);

    Or(a=doJLT, b=doJEQ, out=doJLE);

    // 6가지 jump 조건 중 발생한 것이 있다면 jump를 수행한다.
    // doJGE와, doJLE는 각각 doJGT, doJLT, doJEQ를 이미 포함하고 있으므로 Or로 연산한다.
    Or(a=doJGE, b=doJLE, out=doJMPbyIneqaulity);
    Or(a=doJEQ, b=doJNE, out=doJMPbyZeroOrNotZero);
    Or(a=doJMPbyIneqaulity, b=doJMPbyZeroOrNotZero, out=doJMP);
    Not(in=doJMP, out=doNotJMP);

    // 프로그램 계수기의 기본 동작은 PC(t)=PC(t-1) + 1이다.
    // 또한 load에 따라 주소 레지스터의 값을 입력으로 받을지 아니면 이미 입력된 값에 1을 더할지 결정할 수 있어야 한다.
    // 프로그램 계수시를 마지막으로 처리하는 이유는, instruction이 계산 명령어이고 jump 필드를 가지고 있으며 연산의 결과에 의해 jump를 사용하는지를 알기 위해서는
    // ALU의 연산이 마친 뒤에 확인할 수 있기 때문이다.
    // 마지막으로 컴퓨터가 프로그램을 재실행 할 수 있도록 reset 입력을 PC의 reset에 연결한다.
    PC(in=outAddrReg, load=doJMP, inc=doNotJMP, reset=reset, out[0..14]=pc);
}